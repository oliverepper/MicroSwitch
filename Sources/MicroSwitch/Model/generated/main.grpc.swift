//
// DO NOT EDIT.
//
// Generated by the protocol buffer compiler.
// Source: main.proto
//

//
// Copyright 2018, gRPC Authors All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
import GRPC
import NIO
import SwiftProtobuf


///
/// ServerInfo Service
///
/// To build a server, implement a class that conforms to this protocol.
internal protocol ServerInfoServiceProvider: CallHandlerProvider {
  var interceptors: ServerInfoServiceServerInterceptorFactoryProtocol? { get }

  func info(request: Google_Protobuf_Empty, context: StatusOnlyCallContext) -> EventLoopFuture<ServerInfo>
}

extension ServerInfoServiceProvider {
  internal var serviceName: Substring { return "ServerInfoService" }

  /// Determines, calls and returns the appropriate request handler, depending on the request's method.
  /// Returns nil for methods not handled by this service.
  internal func handle(
    method name: Substring,
    context: CallHandlerContext
  ) -> GRPCServerHandlerProtocol? {
    switch name {
    case "info":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Google_Protobuf_Empty>(),
        responseSerializer: ProtobufSerializer<ServerInfo>(),
        interceptors: self.interceptors?.makeinfoInterceptors() ?? [],
        userFunction: self.info(request:context:)
      )

    default:
      return nil
    }
  }
}

internal protocol ServerInfoServiceServerInterceptorFactoryProtocol {

  /// - Returns: Interceptors to use when handling 'info'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeinfoInterceptors() -> [ServerInterceptor<Google_Protobuf_Empty, ServerInfo>]
}
///
/// PushService
///
/// To build a server, implement a class that conforms to this protocol.
internal protocol PushServiceProvider: CallHandlerProvider {
  var interceptors: PushServiceServerInterceptorFactoryProtocol? { get }

  func add(request: TokenRequest, context: StatusOnlyCallContext) -> EventLoopFuture<Google_Protobuf_Empty>

  func invite(request: InvitationRequest, context: StreamingResponseCallContext<InvitationResponse>) -> EventLoopFuture<GRPCStatus>
}

extension PushServiceProvider {
  internal var serviceName: Substring { return "PushService" }

  /// Determines, calls and returns the appropriate request handler, depending on the request's method.
  /// Returns nil for methods not handled by this service.
  internal func handle(
    method name: Substring,
    context: CallHandlerContext
  ) -> GRPCServerHandlerProtocol? {
    switch name {
    case "add":
      return UnaryServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<TokenRequest>(),
        responseSerializer: ProtobufSerializer<Google_Protobuf_Empty>(),
        interceptors: self.interceptors?.makeaddInterceptors() ?? [],
        userFunction: self.add(request:context:)
      )

    case "invite":
      return ServerStreamingServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<InvitationRequest>(),
        responseSerializer: ProtobufSerializer<InvitationResponse>(),
        interceptors: self.interceptors?.makeinviteInterceptors() ?? [],
        userFunction: self.invite(request:context:)
      )

    default:
      return nil
    }
  }
}

internal protocol PushServiceServerInterceptorFactoryProtocol {

  /// - Returns: Interceptors to use when handling 'add'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeaddInterceptors() -> [ServerInterceptor<TokenRequest, Google_Protobuf_Empty>]

  /// - Returns: Interceptors to use when handling 'invite'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makeinviteInterceptors() -> [ServerInterceptor<InvitationRequest, InvitationResponse>]
}
///
/// AddressBook Service
///
/// To build a server, implement a class that conforms to this protocol.
internal protocol AddressBookServiceProvider: CallHandlerProvider {
  var interceptors: AddressBookServiceServerInterceptorFactoryProtocol? { get }

  func list(request: Google_Protobuf_Empty, context: StreamingResponseCallContext<Handle>) -> EventLoopFuture<GRPCStatus>
}

extension AddressBookServiceProvider {
  internal var serviceName: Substring { return "AddressBookService" }

  /// Determines, calls and returns the appropriate request handler, depending on the request's method.
  /// Returns nil for methods not handled by this service.
  internal func handle(
    method name: Substring,
    context: CallHandlerContext
  ) -> GRPCServerHandlerProtocol? {
    switch name {
    case "list":
      return ServerStreamingServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Google_Protobuf_Empty>(),
        responseSerializer: ProtobufSerializer<Handle>(),
        interceptors: self.interceptors?.makelistInterceptors() ?? [],
        userFunction: self.list(request:context:)
      )

    default:
      return nil
    }
  }
}

internal protocol AddressBookServiceServerInterceptorFactoryProtocol {

  /// - Returns: Interceptors to use when handling 'list'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makelistInterceptors() -> [ServerInterceptor<Google_Protobuf_Empty, Handle>]
}
///
/// Signal Service
///
/// To build a server, implement a class that conforms to this protocol.
internal protocol SignalServiceProvider: CallHandlerProvider {
  var interceptors: SignalServiceServerInterceptorFactoryProtocol? { get }

  func signal(context: StreamingResponseCallContext<Signal>) -> EventLoopFuture<(StreamEvent<Signal>) -> Void>
}

extension SignalServiceProvider {
  internal var serviceName: Substring { return "SignalService" }

  /// Determines, calls and returns the appropriate request handler, depending on the request's method.
  /// Returns nil for methods not handled by this service.
  internal func handle(
    method name: Substring,
    context: CallHandlerContext
  ) -> GRPCServerHandlerProtocol? {
    switch name {
    case "signal":
      return BidirectionalStreamingServerHandler(
        context: context,
        requestDeserializer: ProtobufDeserializer<Signal>(),
        responseSerializer: ProtobufSerializer<Signal>(),
        interceptors: self.interceptors?.makesignalInterceptors() ?? [],
        observerFactory: self.signal(context:)
      )

    default:
      return nil
    }
  }
}

internal protocol SignalServiceServerInterceptorFactoryProtocol {

  /// - Returns: Interceptors to use when handling 'signal'.
  ///   Defaults to calling `self.makeInterceptors()`.
  func makesignalInterceptors() -> [ServerInterceptor<Signal, Signal>]
}
